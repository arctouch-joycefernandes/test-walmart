{"version":3,"sources":["../src/base-test-class.js"],"names":["BaseTest","steps","customizedSettings","self","enumerables","isWorker","settings","env","_","forEach","v","k","Object","defineProperty","enumerable","value","srcFn","prototype","before","client","callback","failures","passed","isAsyncTimeoutSet","isSupposedToFailInBefore","worker","Worker","nightwatch","process","addListener","handleMessage","beforeEach","timeoutsAsyncScript","JS_MAX_TIMEOUT","sessionId","emitMetadata","capabilities","afterEach","results","failed","errors","push","currentTest","module","after","removeListener","exit","end","exports"],"mappings":"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","file":"base-test-class.js","sourcesContent":["import _ from \"lodash\";\nimport settings from \"./settings\";\nimport Worker from \"./worker/magellan\";\n\nconst BaseTest = function (steps, customizedSettings = null) {\n  /**\n   * NOTICE: we don't encourage to pass [before, beforeEach, afterEach, after]\n   *         together with steps into the constructor. PLEASE extend the base test\n   *         and define these four methods there if they are necessary\n   */\n  const self = this;\n  const enumerables = [\"before\", \"after\", \"beforeEach\", \"afterEach\"];\n\n  this.isWorker = settings.isWorker;\n  this.env = settings.env;\n\n  if (customizedSettings) {\n    this.isWorker = customizedSettings.isWorker;\n    this.env = customizedSettings.env;\n  }\n\n  // copy steps to self\n  _.forEach(steps, (v, k) => {\n    Object.defineProperty(self, k,\n      { enumerable: true, value: v });\n  });\n\n  // copy before, beforeEach, afterEach, after to prototype\n  _.forEach(enumerables, (k) => {\n    const srcFn = self[k] || BaseTest.prototype[k];\n    if (srcFn) {\n      Object.defineProperty(self, k,\n        { enumerable: true, value: srcFn });\n    }\n  });\n};\n\nBaseTest.prototype = {\n  /*eslint-disable callback-return*/\n  before(client, callback) {\n    this.failures = [];\n    this.passed = 0;\n\n    // we only want timeoutsAsyncScript to be set once the whole session to limit\n    // the number of http requests we sent\n    this.isAsyncTimeoutSet = false;\n    this.isSupposedToFailInBefore = false;\n\n    if (this.isWorker) {\n      this.worker = new Worker({ nightwatch: client });\n      process.addListener(\"message\", this.worker.handleMessage);\n    }\n    callback();\n  },\n\n  beforeEach(client) {\n    if (!this.isAsyncTimeoutSet) {\n      client.timeoutsAsyncScript(settings.JS_MAX_TIMEOUT);\n      this.isAsyncTimeoutSet = true;\n    }\n\n    // Note: Sometimes, the session hasn't been established yet but we have control.\n    if (client.sessionId) {\n      settings.sessionId = client.sessionId;\n\n      if (this.isWorker) {\n        this.worker.emitMetadata({\n          sessionId: settings.sessionId,\n          capabilities: client.capabilities\n        });\n      }\n    }\n  },\n\n  afterEach(client, callback) {\n    if (this.results) {\n      // in case we failed in `before`\n      // keep track of failed tests for reporting purposes\n      if (this.results.failed || this.results.errors) {\n        // Note: this.client.currentTest.name is also available to display\n        // the name of the specific step within the test where we've failed.\n        this.failures.push(client.currentTest.module);\n      }\n\n      if (this.results.passed) {\n        this.passed += this.results.passed;\n      }\n    }\n\n    if (!this.isAsyncTimeoutSet) {\n      client.timeoutsAsyncScript(settings.JS_MAX_TIMEOUT);\n      this.isAsyncTimeoutSet = true;\n    }\n\n    // Note: Sometimes, the session hasn't been established yet but we have control.\n    if (client.sessionId) {\n      settings.sessionId = client.sessionId;\n\n      if (this.isWorker) {\n        this.worker.emitMetadata({\n          sessionId: settings.sessionId,\n          capabilities: client.capabilities\n        });\n      }\n    }\n\n    callback();\n  },\n\n  /*eslint-disable callback-return*/\n  after(client, callback) {\n    const self = this;\n\n    if (this.isWorker) {\n      process.removeListener(\"message\", self.worker.handleMessage);\n    }\n\n    if (self.isSupposedToFailInBefore) {\n      // there is a bug in nightwatch that if test fails in `before`, test\n      // would still be reported as passed with a exit code = 0. We'll have\n      // to let magellan know the test fails in this way\n      /* istanbul ignore next */\n      /*eslint no-process-exit:0 */\n      /*eslint no-magic-numbers:0 */\n      process.exit(100);\n    }\n    // executor should eat it's own error in summerize()\n\n    client.end();\n    callback();\n\n  }\n};\n\nmodule.exports = BaseTest;\n"]}