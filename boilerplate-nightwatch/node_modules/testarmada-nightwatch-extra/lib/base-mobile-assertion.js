"use strict";

var _events = require("events");

var _events2 = _interopRequireDefault(_events);

var _util = require("util");

var _util2 = _interopRequireDefault(_util);

var _settings = require("./settings");

var _settings2 = _interopRequireDefault(_settings);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Wait until we've seen a selector as :visible SEEN_MAX times, with a
// wait for WAIT_INTERVAL milliseconds between each visibility test.
var MAX_TIMEOUT = _settings2.default.COMMAND_MAX_TIMEOUT;
var WAIT_INTERVAL = _settings2.default.WAIT_INTERVAL;
var SEEN_MAX = _settings2.default.MOBILE_SEEN_MAX;

var Base = function Base() {
  var nightwatch = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

  _events2.default.call(this);

  this.startTime = 0;
  this.time = {
    totalTime: 0,
    seleniumCallTime: 0,
    executeAsyncTime: 0
  };

  this.selector = null;

  this.successMessage = "";
  this.failureMessage = "";

  this.checkConditions = this.checkConditions.bind(this);
  // for mock and unit test
  if (nightwatch) {
    this.client = nightwatch;
  }
};

_util2.default.inherits(Base, _events2.default);

Base.prototype.protocol = function (options, cb) {
  this.client.runProtocolAction(options, cb).send();
};

Base.prototype.checkConditions = function () {
  var self = this;

  var options = {
    path: "/session/" + this.client.sessionId + "/element",
    method: "POST",
    data: {
      using: this.using,
      value: this.selector
    }
  };

  self.protocol(options, function (result) {
    if (result.status === 0) {
      // sucessful
      self.seenCount += 1;
    }

    var elapsed = new Date().getTime() - self.startTime;

    if (self.seenCount >= SEEN_MAX || elapsed > MAX_TIMEOUT) {
      if (self.seenCount >= SEEN_MAX) {
        var elapse = new Date().getTime();
        self.time.executeAsyncTime = elapse - self.startTime;
        self.time.seleniumCallTime = 0;

        self.do(result.value);
      } else {
        self.fail({ code: _settings2.default.FAILURE_REASONS.BUILTIN_SELECTOR_NOT_FOUND });
      }
    } else {
      setTimeout(self.checkConditions, WAIT_INTERVAL);
    }
  });
};

Base.prototype.pass = function (_ref) {
  var actual = _ref.actual,
      expected = _ref.expected,
      message = _ref.message;

  this.time.totalTime = new Date().getTime() - this.startTime;

  this.client.assertion(true, actual, expected, _util2.default.format(this.message, this.time.totalTime), true);
  this.emit("complete");
};

/*eslint max-params:["error", 4] */
Base.prototype.fail = function (_ref2) {
  var code = _ref2.code,
      actual = _ref2.actual,
      expected = _ref2.expected,
      message = _ref2.message;

  // if no code here we do nothing
  var pcode = code ? code : "";

  var pactual = actual || "not visible";
  var pexpected = expected || "visible";
  this.time.totalTime = new Date().getTime() - this.startTime;

  this.client.assertion(false, pactual, pexpected, _util2.default.format(this.message + " [[" + pcode + "]]", this.time.totalTime), true);
  this.emit("complete");
};

/**
 * All children have to implement do
 *
 */
/* istanbul ignore next */
/*eslint no-unused-vars:0 */
Base.prototype.assert = function (actual, expected) {};

/**
 * All children have to implement do
 *
 */
/* istanbul ignore next */
/*eslint no-unused-vars:0 */
Base.prototype.do = function (value) {};

/**
 * All children have to implement command
 *
 */
/* istanbul ignore next */
/*eslint no-unused-vars:0 */
Base.prototype.command = function (using, selector, expected, cb) {
  return this;
};

module.exports = Base;
//# sourceMappingURL=base-mobile-assertion.js.map