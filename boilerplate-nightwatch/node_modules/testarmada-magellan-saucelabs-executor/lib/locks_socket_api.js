"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _ws = require("ws");

var _ws2 = _interopRequireDefault(_ws);

var _logger = require("./logger");

var _logger2 = _interopRequireDefault(_logger);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

//
// How claims work:
//
// 1) An incoming claim callback is pushed to the claims queue by claim(). A claim request
//    is then sent via the websocket.
//
// 2) Locks is expected to eventually respond with a message with a property called "accepted"
//    set to true or false. There are three cases that can happen:
//
//    A) If accepted is set to false, this means the claim was rejected due to saturation, and
//       the saucelabs executor should submit another claim after a short sleep time (as a
//       courtesy to the locks server, which may be under high load during saturation).
//
//    B) If accepted is set to true, this means the claim was accepted and the message's token
//       property should have a unique claim token (this token can be used to liberate the claim
//       early with the release() function).
//
//    C) An error. Not to be confused with a rejected claim, an error means the locks server
//       is in an undefined state or cannot be reached. Things like gateway or network issues
//       can fall into this case. The saucelabs executor can keep retrying until it's convinced
//       that locks is experiencing an outage and it's appropriate to give up.
//

var LocksAPI = function () {
  function LocksAPI(options) {
    var mockSocket = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

    _classCallCheck(this, LocksAPI);

    this.mock = mockSocket ? true : false;
    this.socket = mockSocket ? mockSocket : null;
    this.options = options;
    this.claims = [];
    this.connected = false;
  }

  _createClass(LocksAPI, [{
    key: "_createSocket",
    value: function _createSocket() {
      if (!this.mock) {
        this.socket = new _ws2.default(this.options.locksServerLocation);
      }
    }
  }, {
    key: "connect",
    value: function connect(callback) {
      var _this = this;

      if (!this.connected) {
        this._createSocket();

        this.socket.on("open", function () {
          _logger2.default.debug("Locks websocket established");
          _this.connected = true;
          return callback();
        });

        this.socket.on("error", function (ev) {
          _logger2.default.debug("Locks websocket error");
          return callback(ev.error);
        });

        this.socket.on("close", function () {
          _logger2.default.debug("Locks websocket closed");
          _this.connected = false;
          return;
        });

        this.socket.on("message", function (message) {
          try {
            message = JSON.parse(message);
          } catch (e) {
            var _nextClaim = _this.claims.shift();
            if (_nextClaim) {
              return _nextClaim(e);
            }
          }

          if (message && message.hasOwnProperty("accepted")) {
            var _nextClaim2 = _this.claims.shift();
            if (_nextClaim2) {
              if (message.accepted) {
                return _nextClaim2(null, message.token);
              } else {
                return _nextClaim2(null, null);
              }
            }
          }

          // Reject unexpected or garbled messages
          var nextClaim = _this.claims.shift();
          if (nextClaim) {
            return nextClaim(new Error("Received an unexpected message " + ("from locks server: " + message)));
          }

          return null;
        });

        return null;
      }

      return callback();
    }
  }, {
    key: "_rejectAllClaims",
    value: function _rejectAllClaims(reason, error) {
      var rejectedClaims = this.claims;
      this.claims = [];
      rejectedClaims.forEach(function (nextClaim) {
        if (error) {
          nextClaim(error);
        } else {
          nextClaim(new Error(reason));
        }
      });
    }
  }, {
    key: "claim",
    value: function claim(callback) {
      this.claims.push(callback);
      this.socket.send(JSON.stringify({ type: "claim" }));
    }
  }, {
    key: "release",
    value: function release(token) {
      this.socket.send(JSON.stringify({
        type: "release",
        token: token
      }));
    }
  }, {
    key: "close",
    value: function close() {
      try {
        this._rejectAllClaims("Shutting down");
        if (this.ws) {
          this.socket.close();
        }
      } catch (e) {
        _logger2.default.err("Exception while trying to close websocket: " + e);
      }
    }
  }]);

  return LocksAPI;
}();

exports.default = LocksAPI;
//# sourceMappingURL=locks_socket_api.js.map