"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _lodash = require("lodash");

var _lodash2 = _interopRequireDefault(_lodash);

var _logger = require("./logger");

var _logger2 = _interopRequireDefault(_logger);

var _locks_socket_api = require("./locks_socket_api");

var _locks_socket_api2 = _interopRequireDefault(_locks_socket_api);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Locks = function () {
  function Locks(options) {
    var apiMock = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

    _classCallCheck(this, Locks);

    this.options = _lodash2.default.assign({}, options);
    this.apiMock = apiMock;
  }

  _createClass(Locks, [{
    key: "initialize",
    value: function initialize() {
      var _this = this;

      if (this.options.locksServerLocation) {
        this.api = this.apiMock || new _locks_socket_api2.default(this.options);

        _logger2.default.log("Using locks server at " + this.options.locksServerLocation + " for VM traffic control.");

        return new Promise(function (resolve, reject) {
          _this.api.connect(function (err) {
            if (err) {
              reject(err);
            } else {
              resolve();
            }
          });
        });
      } else {
        return Promise.resolve();
      }
    }

    //
    // 1) Attempt to claim a VM. If the claim is accepted, return the token.
    // 2) If rejected or given an error, wait, then try again (poll)
    // 3) If max polling time is reached, abandon the claim and return an error.
    //

  }, {
    key: "acquire",
    value: function acquire(callback) {
      var _this2 = this;

      if (!this.api) {
        return callback();
      }

      var pollingStartTime = Date.now();

      var poll = function poll() {
        _logger2.default.debug("Asking for VM..");

        try {
          return _this2.api.claim(function (error, token) {
            // Three possible outcomes to claims:
            //
            // 1) error
            // 2) accepted claim, token received.
            // 3) rejected claim, no token received.

            if (error) {
              _logger2.default.err("waited for " + (Date.now() - pollingStartTime) + " , timeout is\n              " + _this2.options.locksOutageTimeout);
              if (Date.now() - pollingStartTime > _this2.options.locksOutageTimeout) {
                // we've been polling for too long. Bail!
                return callback(new Error("" + ("Gave up trying to get " + "a saucelabs VM from locks server. ") + error));
              } else {
                _logger2.default.err("" + ("Error from locks server, tolerating error and" + " waiting ") + _this2.options.locksPollingInterval + "ms before trying again");
                return setTimeout(poll, _this2.options.locksPollingInterval);
              }
            }

            if (token) {
              return callback(null, { token: token });
            } else {
              _logger2.default.debug("Capacity saturated, waiting for clearance to claim next available VM..");
              return setTimeout(poll, _this2.options.locksPollingInterval);
            }
          });
        } catch (e) {
          _logger2.default.err("Internal exception while trying to claim a VM from Saucelabs:");
          _logger2.default.err(e);
          return callback(e);
        }
      };

      return poll();
    }
  }, {
    key: "release",
    value: function release(token) {
      if (!this.api) {
        return;
      }
      this.api.release(token);
    }
  }, {
    key: "teardown",
    value: function teardown() {
      if (!this.api) {
        return;
      }
      this.api.close();
    }
  }]);

  return Locks;
}();

exports.default = Locks;
//# sourceMappingURL=locks.js.map