{"version":3,"sources":["../src/locks_socket_api.js"],"names":["LocksAPI","options","mockSocket","mock","socket","claims","connected","WebSocket","locksServerLocation","callback","_createSocket","on","logger","debug","ev","error","message","JSON","parse","e","nextClaim","shift","hasOwnProperty","accepted","token","Error","reason","rejectedClaims","forEach","push","send","stringify","type","_rejectAllClaims","ws","close","err"],"mappings":"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","file":"locks_socket_api.js","sourcesContent":["import WebSocket from \"ws\";\nimport logger from \"./logger\";\n\n//\n// How claims work:\n//\n// 1) An incoming claim callback is pushed to the claims queue by claim(). A claim request\n//    is then sent via the websocket.\n//\n// 2) Locks is expected to eventually respond with a message with a property called \"accepted\"\n//    set to true or false. There are three cases that can happen:\n//\n//    A) If accepted is set to false, this means the claim was rejected due to saturation, and\n//       the saucelabs executor should submit another claim after a short sleep time (as a\n//       courtesy to the locks server, which may be under high load during saturation).\n//\n//    B) If accepted is set to true, this means the claim was accepted and the message's token\n//       property should have a unique claim token (this token can be used to liberate the claim\n//       early with the release() function).\n//\n//    C) An error. Not to be confused with a rejected claim, an error means the locks server\n//       is in an undefined state or cannot be reached. Things like gateway or network issues\n//       can fall into this case. The saucelabs executor can keep retrying until it's convinced\n//       that locks is experiencing an outage and it's appropriate to give up.\n//\n\nexport default class LocksAPI {\n  constructor(options, mockSocket = null) {\n    this.mock = mockSocket ? true : false;\n    this.socket = mockSocket ? mockSocket : null;\n    this.options = options;\n    this.claims = [];\n    this.connected = false;\n  }\n\n  _createSocket() {\n    if (!this.mock) {\n      this.socket = new WebSocket(this.options.locksServerLocation);\n    }\n  }\n\n  connect(callback) {\n    if (!this.connected) {\n      this._createSocket();\n\n      this.socket.on(\"open\", () => {\n        logger.debug(\"Locks websocket established\");\n        this.connected = true;\n        return callback();\n      });\n\n      this.socket.on(\"error\", (ev) => {\n        logger.debug(\"Locks websocket error\");\n        return callback(ev.error);\n      });\n\n      this.socket.on(\"close\", () => {\n        logger.debug(\"Locks websocket closed\");\n        this.connected = false;\n        return;\n      });\n\n      this.socket.on(\"message\", (message) => {\n        try {\n          message = JSON.parse(message);\n        } catch (e) {\n          const nextClaim = this.claims.shift();\n          if (nextClaim) {\n            return nextClaim(e);\n          }\n        }\n\n        if (message && message.hasOwnProperty(\"accepted\")) {\n          const nextClaim = this.claims.shift();\n          if (nextClaim) {\n            if (message.accepted) {\n              return nextClaim(null, message.token);\n            } else {\n              return nextClaim(null, null);\n            }\n          }\n        }\n\n        // Reject unexpected or garbled messages\n        const nextClaim = this.claims.shift();\n        if (nextClaim) {\n          return nextClaim(new Error(\"Received an unexpected message \"\n            + `from locks server: ${message}`));\n        }\n\n        return null;\n      });\n\n      return null;\n    }\n\n    return callback();\n  }\n\n  _rejectAllClaims(reason, error) {\n    const rejectedClaims = this.claims;\n    this.claims = [];\n    rejectedClaims.forEach((nextClaim) => {\n      if (error) {\n        nextClaim(error);\n      } else {\n        nextClaim(new Error(reason));\n      }\n    });\n  }\n\n  claim(callback) {\n    this.claims.push(callback);\n    this.socket.send(JSON.stringify({ type: \"claim\" }));\n  }\n\n  release(token) {\n    this.socket.send(JSON.stringify({\n      type: \"release\",\n      token\n    }));\n  }\n\n  close() {\n    try {\n      this._rejectAllClaims(\"Shutting down\");\n      if (this.ws) {\n        this.socket.close();\n      }\n    } catch (e) {\n      logger.err(`Exception while trying to close websocket: ${e}`);\n    }\n  }\n\n}\n"]}