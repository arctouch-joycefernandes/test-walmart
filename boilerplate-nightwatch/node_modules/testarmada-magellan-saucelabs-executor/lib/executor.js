"use strict";

var _child_process = require("child_process");

var _locks = require("./locks");

var _locks2 = _interopRequireDefault(_locks);

var _tunnel = require("./tunnel");

var _tunnel2 = _interopRequireDefault(_tunnel);

var _logger = require("./logger");

var _logger2 = _interopRequireDefault(_logger);

var _settings = require("./settings");

var _settings2 = _interopRequireDefault(_settings);

var _global_analytics = require("./global_analytics");

var _global_analytics2 = _interopRequireDefault(_global_analytics);

var _request = require("request");

var _request2 = _interopRequireDefault(_request);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var config = _settings2.default.config;

var tunnel = null;
var locks = null;

var Executor = {
  setupRunner: function setupRunner() {
    var mocks = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;


    var ILocks = _locks2.default;

    if (mocks && mocks.Locks) {
      ILocks = mocks.Locks;
    }

    locks = new ILocks(config);

    return Executor.setupTunnels(mocks).then(function () {
      return locks.initialize();
    });
  },

  setupTunnels: function setupTunnels() {
    var mocks = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

    var ITunnel = _tunnel2.default;

    if (mocks) {
      if (mocks.Tunnel) {
        ITunnel = mocks.Tunnel;
      }
      if (mocks.config) {
        config = mocks.config;
      }
    }

    if (config.useTunnels) {
      // create new tunnel if needed
      tunnel = new ITunnel(config);

      return tunnel.initialize().then(function () {
        _global_analytics2.default.push("sauce-open-tunnels");
        return tunnel.open();
      }).then(function () {
        _global_analytics2.default.mark("sauce-open-tunnels");
        _logger2.default.log("Sauce tunnel is opened!  Continuing...");
        _logger2.default.log("Assigned tunnel [" + config.tunnel.tunnelIdentifier + "] to all workers");
      }).catch(function (err) {
        _global_analytics2.default.mark("sauce-open-tunnels", "failed");
        return new Promise(function (resolve, reject) {
          reject(err);
        });
      });
    } else {
      return new Promise(function (resolve) {
        if (config.tunnel.tunnelIdentifier) {
          var tunnelAnnouncement = config.tunnel.tunnelIdentifier;
          if (config.sharedSauceParentAccount) {
            tunnelAnnouncement = config.sharedSauceParentAccount + "/" + tunnelAnnouncement;
          }
          _logger2.default.log("Connected to sauce tunnel [" + tunnelAnnouncement + "]");
        } else {
          _logger2.default.log("Connected to sauce without tunnel");
        }
        return resolve();
      });
    }
  },

  teardownRunner: function teardownRunner() {
    var mocks = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

    if (mocks && mocks.config) {
      config = mocks.config;
    }

    // shut down locks
    locks.teardown();

    // close tunnel if needed
    if (tunnel && config.useTunnels) {
      return tunnel.close().then(function () {
        _logger2.default.log("Sauce tunnel is closed!  Continuing...");
      });
    } else {
      return new Promise(function (resolve) {
        resolve();
      });
    }
  },

  setupTest: function setupTest(callback) {
    locks.acquire(callback);
  },

  teardownTest: function teardownTest(info, callback) {
    locks.release(info);
    callback(info);
  },

  execute: function execute(testRun, options) {
    var mocks = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

    var ifork = _child_process.fork;

    if (mocks && mocks.fork) {
      ifork = mocks.fork;
    }

    return ifork(testRun.getCommand(), testRun.getArguments(), options);
  },

  /*eslint-disable consistent-return*/
  summerizeTest: function summerizeTest(magellanBuildId, testResult, callback) {
    var additionalLog = "";

    if (!testResult.metadata) {
      // testarmada-nightwatch-extra isn't in use, users need
      // to report result to saucelabs by themselves
      _logger2.default.warn("No meta data is found, executor will not report result to saucelabs" + " This is mainly caused by not using https://github.com/TestArmada/nightwatch-extra");
      return callback();
    }
    try {
      var sessionId = testResult.metadata.sessionId;

      _logger2.default.debug("Saucelabs replay can be found at https://saucelabs.com/tests/" + sessionId + "\n");

      if (!testResult.result) {
        // print out sauce replay to console if test failed
        additionalLog = _logger2.default.stringifyWarn("Saucelabs replay can be found at https://saucelabs.com/tests/" + sessionId + "\n");
      }
      var infoRequestOption = {
        url: "https://saucelabs.com/rest/v1/users/" + config.tunnel.username,
        method: "GET",
        auth: {
          user: config.tunnel.username,
          pass: config.tunnel.accessKey
        },
        body: {},
        json: true
      };

      if (_settings2.default.config.sauceOutboundProxy) {
        infoRequestOption.proxy = _settings2.default.config.sauceOutboundProxy;
        infoRequestOption.strictSSL = false;
      }

      // retrieve account visibility from saucelabs
      (0, _request2.default)(infoRequestOption, function (verror, vres, vjson) {
        if (verror) {
          _logger2.default.err("Error when getting saucelabs account detail for " + config.tunnel.username + ":");
          _logger2.default.err(verror);
          return callback();
        }

        _logger2.default.debug("Response from Saucelabs account detail");
        _logger2.default.debug(JSON.stringify(vjson));

        var visibility = vjson.is_public ? "public" : "team";

        var requestPath = "/rest/v1/" + config.tunnel.username + "/jobs/" + sessionId;
        var data = {
          "passed": testResult.result,
          // TODO: remove this
          "build": magellanBuildId,
          "public": visibility
        };

        _logger2.default.debug("Data posting to SauceLabs job:");
        _logger2.default.debug(JSON.stringify(data));
        _logger2.default.debug("Updating saucelabs " + requestPath);

        var requestOptions = {
          url: "https://saucelabs.com" + requestPath,
          method: "PUT",
          auth: {
            user: config.tunnel.username,
            pass: config.tunnel.accessKey
          },
          body: data,
          json: true
        };

        if (_settings2.default.config.sauceOutboundProxy) {
          requestOptions.proxy = _settings2.default.config.sauceOutboundProxy;
          requestOptions.strictSSL = false;
        }

        (0, _request2.default)(requestOptions, function (error, res, json) {
          if (error) {
            _logger2.default.err("Error when posting update to Saucelabs session with request:");
            _logger2.default.err(error);
            return callback();
          }

          _logger2.default.debug("Response from Saucelabs session update:");
          _logger2.default.debug(JSON.stringify(json));
          return callback(additionalLog);
        });
      });
    } catch (err) {
      _logger2.default.err("Error " + err);
      return callback();
    }
  }

};

module.exports = Executor;
//# sourceMappingURL=executor.js.map