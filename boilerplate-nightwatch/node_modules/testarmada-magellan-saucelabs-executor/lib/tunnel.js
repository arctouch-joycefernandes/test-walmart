"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _sauceConnectLauncher = require("sauce-connect-launcher");

var _sauceConnectLauncher2 = _interopRequireDefault(_sauceConnectLauncher);

var _path = require("path");

var _path2 = _interopRequireDefault(_path);

var _lodash = require("lodash");

var _lodash2 = _interopRequireDefault(_lodash);

var _logger = require("./logger");

var _logger2 = _interopRequireDefault(_logger);

var _settings = require("./settings");

var _settings2 = _interopRequireDefault(_settings);

var _global_analytics = require("./global_analytics");

var _global_analytics2 = _interopRequireDefault(_global_analytics);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Tunnel = function () {
  function Tunnel(options) {
    var sauceConnectLauncherMock = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

    _classCallCheck(this, Tunnel);

    this.options = _lodash2.default.assign({}, options);
    this.sauceConnectLauncher = _sauceConnectLauncher2.default;

    if (sauceConnectLauncherMock) {
      this.sauceConnectLauncher = sauceConnectLauncherMock;
    }
  }

  _createClass(Tunnel, [{
    key: "initialize",
    value: function initialize() {
      var _this = this;

      return new Promise(function (resolve, reject) {
        if (!_this.options.tunnel.username) {
          return reject("Sauce tunnel support is missing configuration: Sauce username.");
        }

        if (!_this.options.tunnel.accessKey) {
          return reject("Sauce tunnel support is missing configuration: Sauce access key.");
        }

        _global_analytics2.default.push("sauce-connect-launcher-download");

        var options = _lodash2.default.assign({}, _this.options.tunnel, { logger: _logger2.default.debug });
        /*eslint-disable no-console */
        return _this.sauceConnectLauncher.download(options, function (err) {
          if (err) {
            _global_analytics2.default.mark("sauce-connect-launcher-download", "failed");
            _logger2.default.err("Failed to download sauce connect binary:");
            _logger2.default.err(err);
            _logger2.default.err("sauce-connect-launcher will attempt to re-download " + "next time it is run.");
            return reject(err);
          } else {
            _global_analytics2.default.mark("sauce-connect-launcher-download");
            return resolve();
          }
        });
      });
    }
  }, {
    key: "open",
    value: function open() {
      var _this2 = this;

      this.tunnelInfo = null;
      var connectFailures = 0;

      _logger2.default.log("Opening sauce tunnel [" + this.options.tunnel.tunnelIdentifier + "]" + (" for user " + this.options.tunnel.username));

      var connect = function connect() /*runDiagnostics*/{
        return new Promise(function (resolve, reject) {
          var logFilePath = _path2.default.resolve(_settings2.default.tempDir) + "/build-" + _settings2.default.buildId + "_sauceconnect_" + _this2.options.tunnel.tunnelIdentifier + ".log";

          var sauceOptions = _lodash2.default.assign({}, _this2.options.tunnel, {
            readyFileId: _this2.options.tunnel.tunnelIdentifier,
            verbose: _settings2.default.debug,
            verboseDebugging: _settings2.default.debug,
            logfile: logFilePath,
            port: _settings2.default.BASE_SELENIUM_PORT_OFFSET
          });

          _logger2.default.debug("calling sauceConnectLauncher() w/ " + JSON.stringify(sauceOptions));

          _this2.sauceConnectLauncher(sauceOptions, function (err, sauceConnectProcess) {
            if (err) {
              _logger2.default.debug("Error from sauceConnectLauncher():");
              _logger2.default.debug(err.message);

              if (err.message && err.message.indexOf("Could not start Sauce Connect") > -1) {
                return reject(err.message);
              } else if (_settings2.default.BAILED) {
                connectFailures++;
                // If some other parallel tunnel construction attempt has tripped the BAILED flag
                // Stop retrying and report back a failure.
                return reject(new Error("Bailed due to maximum number of tunnel retries."));
              } else {
                connectFailures++;

                if (connectFailures >= _settings2.default.MAX_CONNECT_RETRIES) {
                  // We've met or exceeded the number of max retries, stop trying to connect.
                  // Make sure other attempts don't try to re-state this error.
                  _settings2.default.BAILED = true;
                  return reject(new Error("Failed to create a secure sauce tunnel after " + connectFailures + " attempts."));
                } else {
                  // Otherwise, keep retrying, and hope this is merely a blip and not an outage.
                  _logger2.default.err(">>> Sauce Tunnel Connection Failed!  Retrying " + connectFailures + " of " + _settings2.default.MAX_CONNECT_RETRIES + " attempts...");

                  return connect().then(resolve).catch(reject);
                }
              }
            } else {
              _this2.tunnelInfo = { process: sauceConnectProcess };
              return resolve();
            }
          });
        });
      };

      return connect();
    }
  }, {
    key: "close",
    value: function close() {
      var _this3 = this;

      return new Promise(function (resolve) {
        if (_this3.tunnelInfo) {
          _logger2.default.log("Closing sauce tunnel [" + _this3.options.tunnel.tunnelIdentifier + "]");
          _this3.tunnelInfo.process.close(function () {
            resolve();
          });
        } else {
          resolve();
        }
      });
    }
  }]);

  return Tunnel;
}();

exports.default = Tunnel;
//# sourceMappingURL=tunnel.js.map